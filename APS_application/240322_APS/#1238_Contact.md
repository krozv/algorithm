# [SWEA] 1238. Contact

가장 나중에 연락을 받게 되는 사람?

## 자료구조

단방향 그래프

## 알고리즘

BFS, MST, Dijkstra 등

## condition
### 문제
- 연락할 수 있는 다른 노드가 동시에 연락
- BFS. 과연 맞을까? 검증하는 과정 필요
- 문제를 보니 노드 탐색 = BFS 알고리즘 맞음 but, 추가로 필요한 기능이 존재
- 마지막에 연락한 노드 중 가장 큰 숫자가 반환되어야 함
### 내 생각
1. 생각 1
    - bfs를 하면서 visited의 숫자를 방문 순서로 저장함
    - 탐색 완료 후 visited가 가장 큰 숫자들의 목록에서 가장 큰 숫자만을 정답으로 반환
2. 생각 2
    - 방문순서를 키로 하여금 딕셔너리를 생성.
    - 방문순서가 일치하는 키에 숫자들 집어넣음
    - 마지막 키의 가장 큰 숫자 반환
### 강의
- N번 만에 해당 노드를 탐색했다는 정보 필요 = level, depth
- 마지막 level에서 숫자가 가장 큰 노드 = flood fill algorithm 참고해볼 것
1. 시간 복잡도, 공간 복잡도도 고려해야 합니당
    - 1초당 tc 1개씩
    - 1초 == 1억번 루프 가능
2. BFS의 시간복잡도
    - 얼마나 방문할 수 있을까?
    - 노드의 수가 최대 100개라면 -> 최대 V: 100, E: 99
    - 인접 리스트 기준 시간복잡도: O(V+E) = O(100+10,000) -> 완전탐색 가능
    ```
    자주 사용하는 알고리즘의 시간복잡도 외워둘것!
    ```


        
    

